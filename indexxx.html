<!DOCTYPE HTML>
<html>
<head>
	<title>Three JS Test</title>
	<!-- CSS style definitions -->
	<style>
	body {
		margin: 0;
	}
	canvas {
		width: 100%;
		height: 100%;
		background-color: #FFFFFF;
	}
	a {
		text-decoration: none;
		font-family: Arial, Helvetica, sans-serif;
		color: white;
	}
	div.lisays {
		position: fixed;
		background-color: #FFFFFF;
		top: 10%;
		left: 3%;
	}
	div.takaisin {
		padding-top: 10px;
		padding-bottom: 10px;
		padding-left: 5px;
		padding-right: 5px;
		position: fixed;
		background-color: #595959;
		top: 1%;
		left: 3%;
		border-left: 6px solid white;
		transition-duration: 0.4s;
		width: 100px;
	}
	div.takaisin:hover {
		border-left: 6px solid white;
		background-color: #808080;
	}
	/*
	div.incs {
		top: 90%;
		width: 90%;
		position: fixed;
		background-color: white;
		text-align: center;
	}
	*/
	button#cube {
		width: 100px;
		background-color: black;
		border-radius: 5px;
		border: none;
		transition-duration: 0.4s;
		border: 2px solid #e7e7e7;
	}
	button#cube:hover {
		background-color: green;
		cursor: pointer;
	}
	button#cube:active {
		background-color: yellow;
		cursor: pointer;
	}
	button#cube span {
        color: white;
    }
    ui-widget-content.success-dialog {
   		background: #F9F9F9;
    	border: 1px solid #90d93f;
    	color: #222222;
	}

	.ui-dialog.success-dialog {
    	left: 0;
    	outline: 0 none;
    	padding: 0 !important;
    	position: absolute;
    	top: 0;
	}

	.ui-dialog.success-dialog .ui-dialog-content {
    	background: none repeat scroll 0 0 transparent;
    	border: 0 none;
    	overflow: auto;
    	position: relative;
    	padding: 0 !important;
    	margin: 0;
	}

	.ui-dialog.success-dialog .ui-widget-header {
    	background: #b0de78;
    	border: 0;
    	color: #fff;
    	font-weight: normal;
	}

	.ui-dialog.success-dialog .ui-dialog-titlebar {
    	padding: 0.1em .5em;
    	position: relative;
    	font-size: 1em;
	}
	</style>
</head>
<body>
	<!--Linking JavaScript and CSS-files-->
	<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="/resources/demos/style.css">
	<script src = "three.min.js"></script>
	<script src = "OrbitControls.js"></script>
	<script src = "dat.gui.min.js"></script>
	<script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
	<script type = "text/javascript">

	//Some variables
	var scene, camera, renderer;
	var mouse = new THREE.Vector2();
	var objects = [];
	var raycaster = new THREE.Raycaster();
	var container;
	var SELECTED;
	var INTERSECTED;
	var intersection = new THREE.Vector3();
	var offset = new THREE.Vector3();
	var controls;
	var trees = 0;
	var plane = new THREE.Plane();

	var i = 0;
	var dragged = false;
	var selectedId;

	init();
	//animate();

    //Initializer-function to initialize the whole thing
	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		//Creating scene. Scene is where everything is added.
		scene = new THREE.Scene();

		//Creating camera and giving it its position
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
		camera.position.set(30,20,0);
		camera.lookAt(scene.position);

        //Renderer stuff
		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

        //Building some block of flats
		var cubeWidth = 5;
        var cubeHeight = 5;
        var cubeDepth = 15;            
        var cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        var cubeMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc, vertexColors: 'white', wireframeLinewidth: 3});                
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.y = 2.45;
        cube.position.x = -8;
        cube.position.z = 0.5;           
        scene.add(cube);

        cubeWidth = 15;
        cubeHeight = 5;
        cubeDepth = 5;            
        cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        cubeMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc, vertexColors: 'white', wireframeLinewidth: 3});                
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.y = 2.45;
        cube.position.x = 3;
        cube.position.z = 11;
        scene.add(cube);

        cubeWidth = 15;
        cubeHeight = 5;
        cubeDepth = 5;            
        cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        cubeMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc, vertexColors: 'white', wireframeLinewidth: 3});                
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.y = 2.45;
        cube.position.x = 3;
        cube.position.z = -11;
        scene.add(cube);

        //Adding event listeners to elements
        renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
		renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
		renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
		renderer.domElement.addEventListener( 'click', onDocumentMouseClick, false );

        ray = new THREE.Ray( camera.position, null );

        //Creating plane
        var geometry = new THREE.PlaneBufferGeometry( 30, 30, 32 );
		var material = new THREE.MeshBasicMaterial( {color: 0x009933, side: THREE.DoubleSide} );
		var planee = new THREE.Mesh( geometry, material );
		planee.position.y = 0;
		planee.rotation.x = Math.PI / 2;
		scene.add( planee );

		//Creating controls. Now itÃ¤s possible to rotate the view and zoom
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.addEventListener( 'change', render );

		//Setting limits to rotation and zoom.
		//Vertical rotation is limited, so that it's not possible to look under the plane.
		controls.minPolarAngle = - Math.PI;
		controls.maxPolarAngle = Math.PI / 2 - 0.2;

		//No limits for horizontal rotation
		controls.minAzimuthAngle = -Infinity; // radians
		controls.maxAzimuthAngle = Infinity; // radians

		//Zoom limits
		controls.minDistance = 0;
		controls.maxDistance = 30;

		//Adding event listener of window if window is resized
		window.addEventListener( 'resize', onWindowResize, false );

		//Render the scene together
		render();
	}

	//When window is resized, this function is called resizing window automatically
	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );
		render();
	}

	//When moving mouse (while pressing down), this function is called

	function onDocumentMouseMove( event ) {

        dragged = true;
		event.preventDefault();
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		//Raycaster let us know which object is selected
		raycaster.setFromCamera( mouse, camera );

		if ( SELECTED ) {

			if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

				SELECTED.position.copy( intersection.sub( offset ) );

				//Rendering while mouse is dragging object.
				render();
		    }

		return;
		}

		var intersects = raycaster.intersectObjects( objects );

		if ( intersects.length > 0 ) {

			if ( INTERSECTED != intersects[ 0 ].object ) {

				if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

				INTERSECTED = intersects[ 0 ].object;
				INTERSECTED.currentHex = INTERSECTED.material.color.getHex();

				//Dir-vector is normal-vector for plane.
				var dir = new THREE.Vector3(0,200,0);
				var centroid = new THREE.Vector3(0,0,0);
				plane.setFromNormalAndCoplanarPoint(dir, centroid);

				//plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection( plane.normal ),INTERSECTED.position );
			}

			container.style.cursor = 'pointer';

		} else {

			if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

			INTERSECTED = null;
			container.style.cursor = 'auto';
		}
		render();
	}

	//When mouse down, this function is called

	function onDocumentMouseDown( event ) {

        dragged = false;
		event.preventDefault();
		raycaster.setFromCamera( mouse, camera );
		var intersects = raycaster.intersectObjects( objects );

		if ( intersects.length > 0 ) {

			controls.enabled = false;
			SELECTED = intersects[ 0 ].object;

			if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

				offset.copy( intersection ).sub( SELECTED.position );

			}
			container.style.cursor = 'move';
		}
		render();

	}

	//When mouse is up, this function is called

	function onDocumentMouseUp( event ) {

		event.preventDefault();
		controls.enabled = true;

		if ( INTERSECTED ) {
			SELECTED = null;
		}

		if ( dragged ) {
			setTimeout(function(){ui.helper.unbind("click.prevent");}, 300);
		}

		container.style.cursor = 'auto';
		render();

	}

	//When clicked mouse on object, this function is called

	function onDocumentMouseClick(event) {
		event.preventDefault();
		raycaster.setFromCamera( mouse, camera );
		var intersects = raycaster.intersectObjects( objects );
		if (INTERSECTED && !dragged) {
			var xco = INTERSECTED.position.z.toFixed(2); 
			var zco = INTERSECTED.position.x.toFixed(2);
			document.getElementById('oi').innerHTML = INTERSECTED.userData.id;
			selectedId = INTERSECTED.userData.id;
			document.getElementById('ox').innerHTML = INTERSECTED.position.x.toFixed(2);
			document.getElementById('oz').innerHTML = INTERSECTED.position.z.toFixed(2); 
			$('#success').dialog({
				height: 150,
				width: 350,
				modal: true,
    			resizable: false,
				dialogClass: 'no-close success-dialog'
			});
		}
	}

	function removeObject() {
		
	}

	//Animation function. Not needed...
	function animate() {
		requestAnimationFrame( animate );
		render();
	}

	//Rendering function
	function render() {

		var timer = Date.now() * 0.0005;
		camera.lookAt( scene.position );
		renderer.render(scene, camera);
	}

	//Function to add cubes
	function addCube() {
		var xco = 0;
		var zco = 0;
		var cubeWidth = 1;
        var cubeHeight = 1;
        var cubeDepth = 1;            
        var cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        var cubeMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, vertexColors: 'white', wireframeLinewidth: 3});                
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.y = 0.45;
        cube.position.x = xco;
        cube.position.z = zco;
        cube.userData.id = i;
        i++;
        objects.push(cube);
          
        scene.add(cube);
        render();
	}
	//Function to add "trees"

	function addTree() {
		var xco = prompt("Please enter y-coord");
		var zco = prompt("Please enter x-koord");
		var cubeWidth = 0.1;
        var cubeHeight = 2;
        var cubeDepth = 0.1;            
        var cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        var cubeMaterial = new THREE.MeshBasicMaterial({color: 0x993300, vertexColors: 'white', wireframeLinewidth: 3});                
        tree = new THREE.Mesh(cubeGeometry, cubeMaterial);
        tree.position.y = 0.95;
        tree.position.x = xco;
        tree.position.z = zco;

        var geometry = new THREE.SphereGeometry(1, 32, 32);
        var material = new THREE.MeshBasicMaterial({color: 0x00ff00});
        var sphere = new THREE.Mesh(geometry, material);
        sphere.position.y = 0.95 + cubeHeight;
        sphere.position.x = xco;
        sphere.position.z = zco;
        objects.push(sphere);
        scene.add(sphere);
        render();
        scene.add(tree);
        trees++;
        updateBackground();
        document.getElementById('puut').innerHTML = trees;
        render();
	}

	//Function to change background color of the game
	function updateBackground() {
		if (trees > 2) {
			scene.background = new THREE.Color( 0xC1FFFF );
			render();
		}
	}

	</script>
	<div class = "takaisin"><a href = "mapstesti.html">Back to map</a></div>
	<div class = "lisays"><button id = "cube" onclick = "addCube()"><span>Add cube!</span></button><br><!--<button onclick = "addTree()">Add tree!</button>--></div>
	<div id="success" title="Cube">
    <p>You have clicked an object! Object index: <p id = "oi"></p>Location: <p id = "ox"></p><p id = "oz"></p><button onclick = "removeObject()">Remove object</button></p>
</div>
	<!--<div class = "incs">Click add cube to add cube to yard. Drag and drop it to the place you want<br>Delete cube by doubleclicking it</div>--><!--<button onclick = "addTree()">Add tree!</button></div>-->

	<!--<div class = "pisteet">
		<div id = "puut">0</div>
	</div>-->
</body>
</html>
