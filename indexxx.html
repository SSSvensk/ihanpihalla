<!DOCTYPE HTML>
<html>
<head>
	<title>Three JS Test</title>
	<!-- CSS style definitions -->
	<style>
	body {
		margin: 0;
		width: 100%;
		height: 100%;
	}
	canvas {
		display: block;
		width: 100%;
		height: 100%;
		background-color: #FFFFFF;
	}
	a {
		text-decoration: none;
		font-family: Arial, Helvetica, sans-serif;
		color: white;
	}
	div.lisays {
		position: fixed;
		background-color: #FFFFFF;
		top: 10%;
		left: 3%;
	}
	div.takaisin {
		padding-top: 10px;
		padding-bottom: 10px;
		padding-left: 5px;
		padding-right: 5px;
		position: fixed;
		background-color: #595959;
		top: 1%;
		left: 3%;
		border-left: 6px solid white;
		transition-duration: 0.4s;
		width: 100px;
	}
	div.takaisin:hover {
		border-left: 6px solid white;
		background-color: #808080;
	}
	div#success {
		display: none;
	}
	div#details {
		position: fixed;
		width: 10%;
		bottom: 5%;
		left: 3%;
		background-color: white;
	}
	/*
	div.incs {
		top: 90%;
		width: 90%;
		position: fixed;
		background-color: white;
		text-align: center;
	}
	*/
	button#cube {
		width: 100px;
		background-color: black;
		border-radius: 5px;
		border: none;
		transition-duration: 0.4s;
		border: 2px solid #e7e7e7;
	}
	button#cube:hover {
		background-color: green;
		cursor: pointer;
	}
	button#cube:active {
		background-color: yellow;
		cursor: pointer;
	}
	button#cube span {
        color: white;
    }
    ui-widget-content.success-dialog {
   		background: #F9F9F9;
    	border: 1px solid #90d93f;
    	color: #222222;
	}

	.ui-dialog.success-dialog {
    	left: 0;
    	outline: 0 none;
    	padding: 0 !important;
    	position: absolute;
    	top: 0;
	}

	.ui-dialog.success-dialog .ui-dialog-content {
    	background: none repeat scroll 0 0 transparent;
    	border: 0 none;
    	overflow: auto;
    	position: relative;
    	padding: 0 !important;
    	margin: 0;
	}

	.ui-dialog.success-dialog .ui-widget-header {
    	background: #b0de78;
    	border: 0;
    	color: #fff;
    	font-weight: normal;
	}

	.ui-dialog.success-dialog .ui-dialog-titlebar {
    	padding: 0.1em .5em;
    	position: relative;
    	font-size: 1em;
	}
	</style>
</head>
<body>
	<!--Linking JavaScript and CSS-files-->
	<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
    <link rel="stylesheet" href="/resources/demos/style.css">
	<script src = "three.min.js"></script>
	<script src = "OrbitControls.js"></script>
	<script src = "OBJLoader.js"></script>
	<script src = "dat.gui.min.js"></script>
	<script src = "Cube.js"></script>
	<script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
	<script type = "text/javascript">

	//Some variables
	var scene, camera, renderer;
	var mouse = new THREE.Vector2();
	var objects = [];
	var raycaster = new THREE.Raycaster();
	var container;
	var SELECTED;
	var INTERSECTED;
	var ADDED;
	var intersection = new THREE.Vector3();
	var offset = new THREE.Vector3();
	var controls;
	var trees = 0;
	var plane = new THREE.Plane();
	var allObjects = [];

	var i = 0;
	var dragged = false;
	var selectedId;
	var borderX, borderY;
	var borderXX, borderYY;

	var previousX;
	var previousZ;
	var onTop;

	init();
	//animate();

    //Initializer-function to initialize the whole thing
	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		//Creating scene. Scene is where everything is added.
		scene = new THREE.Scene();

		//Creating camera and giving it its position
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
		camera.position.set(30,20,0);
		camera.lookAt(scene.position);

        //Renderer stuff
		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;

		renderer.shadowCameraNear = 3;
		renderer.shadowCameraFar = camera.far;
		renderer.shadowCameraFov = 50;

		renderer.shadowMapBias = 0.0039;
		renderer.shadowMapDarkness = 0.5;
		renderer.shadowMapWidth = 1024;
		renderer.shadowMapHeight = 1024;

        //Building some block of flats
		var cubeWidth = 1;
        var cubeHeight = 1;
        var cubeDepth = 1;            
        var cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        //var cubeTexture = new THREE.TextureLoader().load('wooden.jpg');
        var cubeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});                
        var cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.scale.set( 5, 5, 15 );
        cube.position.y = 2.45;
        cube.position.x = -8;
        cube.position.z = 0.5; 
        cube.castShadow = true;
		cube.receiveShadow = true; 
        allObjects.push(cube);         
        scene.add(cube);

        cubeWidth = 1;
        cubeHeight = 1;
        cubeDepth = 1;            
        cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        //cubeTexture = new THREE.TextureLoader().load('wooden.jpg');
        cubeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});                
        var newCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        newCube.scale.set( 15, 5, 5 );
        newCube.position.y = 2.45;
        newCube.position.x = 3;
        newCube.position.z = 11;
        newCube.castShadow = true;
		newCube.receiveShadow = true; 
        allObjects.push(newCube);
        scene.add(newCube);

        cubeWidth = 1;
        cubeHeight = 1;
        cubeDepth = 1;            
        cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        //cubeTexture = new THREE.TextureLoader().load('wooden.jpg');
        cubeMaterial = new THREE.MeshLambertMaterial({color: 0xcccccc});                  
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.scale.set( 15, 5, 5 );
        cube.position.y = 2.45;
        cube.position.x = 3;
        cube.position.z = -11;
        cube.castShadow = true;
		cube.receiveShadow = true; 
        allObjects.push(cube);
        scene.add(cube);

        //Different lights. Pick your favourite
/*
        var light = new THREE.AmbientLight( 0x404040 ); // soft white light
		scene.add( light );
/*
		var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
		directionalLight.position.set( 0, 20, 10 );
		directionalLight.castShadow = true;
		scene.add( directionalLight );

		var pointLight = new THREE.PointLight( 0xffffff, 1.5, 40 );
		pointLight.position.set( 0, 5, 0 );
		pointLight.castShadow = true;
		scene.add( pointLight );
*/
		var hemiLight = new THREE.HemisphereLight( 0xffffff, 0x080820, 1 );
		scene.add( hemiLight );

        //Adding event listeners to elements
        renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
		renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
		renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
		renderer.domElement.addEventListener( 'click', onDocumentMouseClick, false );

        ray = new THREE.Ray( camera.position, null );

        //Creating plane
        var geometry = new THREE.PlaneBufferGeometry( 30, 30, 32 );
		
		var texture = THREE.ImageUtils.loadTexture( "grass5.jpg" );

		//Making texture spread in 2 directions. Without these, texture would look like bar code
		texture.wrapS = THREE.RepeatWrapping; 
		texture.wrapT = THREE.RepeatWrapping;

		//Repeating texture, lower the number is, lower the quality is...
		texture.repeat.set( 6, 6 ); 

		//Settng texture as map for material
		var material = new THREE.MeshLambertMaterial( {map:texture} );

		//Creating plane
		var planee = new THREE.Mesh( geometry, material );

		//Just inserting coordinates of borders to variables
		borderY = borderX = 15
		borderYY = borderXX = -15;

		//Setting plane's position and rotation. If you remove minus in front of the rotation, the texture stays on the bottom
		planee.position.y = 0;
		planee.rotation.x = - Math.PI / 2;

		//Finally adding the plane to the scene
		scene.add( planee );

		//Setting vectors which define basically in which direction is the yard is and in which direction cubes move
		var dir = new THREE.Vector3(0,200,0);
		var centroid = new THREE.Vector3(0,0.45,0);
		plane.setFromNormalAndCoplanarPoint(dir, centroid);
/*
		//Introducing .obj-file loader.
		var loader = new THREE.OBJLoader();


		// load a resource
		loader.load(
			// resource URL
			'LS13_01.obj',
			// Function when resource is loaded
			function ( object ) {
				object.position.x = 3;
				object.position.z = 3;
				object.scale.y = 4;
				object.scale.x = 4;
				object.scale.z = 4;
				scene.add( object );
				allObjects.push(object);
				objects.push(object);
			}
		);
*/

		//Creating controls. Now it's possible to rotate the view and zoom
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.addEventListener( 'change', render );

		//Setting limits to rotation and zoom.
		//Vertical rotation is limited, so that it's not possible to look under the plane.
		controls.minPolarAngle = - Math.PI;
		controls.maxPolarAngle = Math.PI / 2 - 0.2;

		//No limits for horizontal rotation
		controls.minAzimuthAngle = -Infinity; // radians
		controls.maxAzimuthAngle = Infinity; // radians

		//Zoom limits
		controls.minDistance = 0;
		controls.maxDistance = 30;

		//Adding event listener of window if window is resized
		window.addEventListener( 'resize', onWindowResize, false );

		//Render the scene together
		render();
	}

	//When window is resized, this function is called resizing window automatically
	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		//Render after resize to show the change immediately
		render();
	}

	//When moving mouse, this function is called

	function onDocumentMouseMove( event ) {

        dragged = true;
		event.preventDefault();
		mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

		//Raycaster let us know which object is selected
		raycaster.setFromCamera( mouse, camera );

		//If object is selected and object is inside yard

		if ( SELECTED && (SELECTED.position.x < 14.5 && SELECTED.position.x > -14.5 && SELECTED.position.z < 14.5 && SELECTED.position.z > -14.5 )) {

            var ot = checkObjectsNotTopOfEachOther();
			if ( raycaster.ray.intersectPlane( plane, intersection ) && ot == 0) {

				SELECTED.position.copy( intersection.sub( offset ) );

				//Rendering while mouse is dragging object.
				render();
		    } else {
		    	cancelDragAndDrop();
		    }

		return;
		}

		else if (ADDED) {
			//var ot = checkObjectsNotTopOfEachOther();
			if ( raycaster.ray.intersectPlane( plane, intersection )) {

				ADDED.position.copy( intersection.sub( offset ) );

				//Rendering while mouse is dragging object.
				if ((ADDED.position.x < 14.5 && ADDED.position.x > -14.5) && (ADDED.position.z < 14.5 && ADDED.position.z > -14.5)) {

					render();
				}
		    } 
		    return;
		}

		//Else if object is selected but outside yard limits
		//Then it's returned back to its previous location before drag&drop and no more selected
		else if ( SELECTED && (SELECTED.position.x > 14.5 || SELECTED.position.x < -14.5 || SELECTED.position.z > 14.5 || SELECTED.position.z < -14.5 )) {
			cancelDragAndDrop();
			alert("Object over bounds!");
		}

		//Storing every object, that are penetrated by ray, to intersects-array
		var intersects = raycaster.intersectObjects( objects );

		if ( intersects.length > 0 ) {
			if ( INTERSECTED != intersects[ 0 ].object ) {

				if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

				INTERSECTED = intersects[ 0 ].object;

				//Preserves the color/texture
				INTERSECTED.currentHex = INTERSECTED.material.color.getHex();
				//plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection( plane.normal ),INTERSECTED.position );
			}

			container.style.cursor = 'pointer';

		} else {

			if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

			INTERSECTED = null;
			container.style.cursor = 'auto';
		}
		render();
	}

	//When mouse down, this function is called
	function onDocumentMouseDown( event ) {

        dragged = false;
		event.preventDefault();
		raycaster.setFromCamera( mouse, camera );
		var intersects = raycaster.intersectObjects( objects, true );

		if ( intersects.length > 0 ) {

			//Not able to rotate the view or zoom while mousedown on object
			//Only focusing on clicked object now...
			controls.enabled = false;

			//Picking selected object
			SELECTED = intersects[ 0 ].object;
			previousZ = SELECTED.position.z;
			previousX = SELECTED.position.x;

			if ( raycaster.ray.intersectPlane( plane, intersection ) ) {

				offset.copy( intersection ).sub( SELECTED.position );

			}
			container.style.cursor = 'move';
		}
		render();

	}

	//When mouse is up, this function is called
	function onDocumentMouseUp( event ) {

		//document.getElementById('success').innerHTML.display = "none";
		event.preventDefault();
		controls.enabled = true;

		if ( INTERSECTED) {
			SELECTED = null;
		}

		if ( dragged ) {
			setTimeout(function(){ui.helper.unbind("click.prevent");}, 300);
		}

		container.style.cursor = 'auto';
		render();

	}

	//When clicked mouse on object, this function is called

	function onDocumentMouseClick(event) {
		event.preventDefault();
		controls.enabled = true;
		if (ADDED && ((ADDED.position.x < 14.5 && ADDED.position.x > -14.5) && (ADDED.position.z < 14.5 && ADDED.position.z > -14.5))) {
			SELECTED = null;
			ADDED = null;
			render();
			//return;
		} else {
		event.preventDefault();
		raycaster.setFromCamera( mouse, camera );
		var intersects = raycaster.intersectObjects( objects );
		if (INTERSECTED && !dragged) {
			var xco = INTERSECTED.position.z.toFixed(2); 
			var zco = INTERSECTED.position.x.toFixed(2);
			document.getElementById('oi').innerHTML = INTERSECTED.userData.id;
			selectedId = INTERSECTED.userData.id;
			document.getElementById('ox').innerHTML = INTERSECTED.position.x.toFixed(2);
			document.getElementById('oz').innerHTML = INTERSECTED.position.z.toFixed(2); 
			$('#success').dialog({
				height: 150,
				width: 350,
				modal: true,
    			resizable: false,
				dialogClass: 'no-close success-dialog'
			});
		}
	}
	document.getElementById('details').innerHTML = allObjects[0].scale.z;
	}

	function checkObjectsNotTopOfEachOther() {
		if (SELECTED) {
		var ind = allObjects.indexOf(SELECTED);
		var sxo = SELECTED.position.x + (SELECTED.scale.x / 2);
		var sxt = SELECTED.position.x - (SELECTED.scale.x / 2);
		var szo = SELECTED.position.z + (SELECTED.scale.z / 2);
		var szt = SELECTED.position.z - (SELECTED.scale.z / 2);

		for (var i = 0; i < allObjects.length; i++) {
			if (i != ind) {
				var aoxo = allObjects[i].position.x + (allObjects[i].scale.x / 2);
				var aoxt = allObjects[i].position.x - (allObjects[i].scale.x / 2);
				var aozo = allObjects[i].position.z + (allObjects[i].scale.z / 2);
				var aozt = allObjects[i].position.z - (allObjects[i].scale.z / 2);
				if (((sxo >= aoxt) && (szo >= aozt) && (szt <= aozt) && (sxt <= aoxt)) || ((szo >= aozt) && (sxt <= aoxo) && (sxo >= aoxo) && (szt <= aozt)) || ((aoxo >= sxt) && (aozo >= szt) && (aozt <= szt) && (aoxt <= sxt)) || ((aozo >= szt) && (aoxt <= sxo) && (aoxo >= sxo) && (aozt <= szt))) {
					onTop = 1;
					break;
				} else {
					onTop = 0;
				}
			}
		};
		return onTop;
	}
	/*
	else {
		var sxo = ADDED.position.x + (ADDED.scale.x / 2);
		var sxt = ADDED.position.x - (ADDED.scale.x / 2);
		var szo = ADDED.position.z + (ADDED.scale.z / 2);
		var szt = ADDED.position.z - (ADDED.scale.z / 2);

		for (var i = 0; i < allObjects.length; i++) {
				var aoxo = allObjects[i].position.x + (allObjects[i].scale.x / 2);
				var aoxt = allObjects[i].position.x - (allObjects[i].scale.x / 2);
				var aozo = allObjects[i].position.z + (allObjects[i].scale.z / 2);
				var aozt = allObjects[i].position.z - (allObjects[i].scale.z / 2);
				if (((sxo >= aoxt) && (szo >= aozt) && (szt <= aozt) && (sxt <= aoxt)) || ((szo >= aozt) && (sxt <= aoxo) && (sxo >= aoxo) && (szt <= aozt)) || ((aoxo >= sxt) && (aozo >= szt) && (aozt <= szt) && (aoxt <= sxt)) || ((aozo >= szt) && (aoxt <= sxo) && (aoxo >= sxo) && (aozt <= szt))) {
					onTop = 1;
					break;
				} else {
					onTop = 0;
			}
		};
		return onTop;
	}
	*/
	}

	function removeObject() {
		var ind = objects.indexOf(INTERSECTED);
		var indd = allObjects.indexOf(INTERSECTED);
		objects.splice(ind, 1);
		allObjects.splice(indd, 1);
		scene.remove(INTERSECTED);
		render();
	}

	function cancelDragAndDrop() {
		scene.remove(SELECTED);
		SELECTED.position.x = previousX;
		SELECTED.position.z = previousZ;
		scene.add(SELECTED);
		SELECTED = null;
	}

	//Animation function. Not needed...
	function animate() {
		requestAnimationFrame( animate );
		render();
	}

	//Rendering function
	function render() {
		var timer = Date.now() * 0.0005;
		camera.lookAt( scene.position );
		renderer.render(scene, camera);
	}

	//Function to add cubes
	function addCube() {
		//mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
		//mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		var xco = 200;
		var zco = 200;
		var cubeWidth = 1;
        var cubeHeight = 1;
        var cubeDepth = 1;
        var texture = new THREE.TextureLoader().load('brick.jpg');
        var cubeGeometry = new THREE.CubeGeometry(cubeWidth, cubeHeight, cubeDepth);
        var cubeMaterial = new THREE.MeshLambertMaterial( { map: texture } );
        //var cubeMaterial = new THREE.MeshLambertMaterial({color: 0x00ff00, vertexColors: 'white', wireframeLinewidth: 3});                
        cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        cube.position.y = 0;
        cube.position.x = xco;
        cube.position.z = zco;
        cube.userData.id = i;
        ADDED = cube;
        i++;
        cube.castShadow = true;
		cube.receiveShadow = true; 
		var yCube = new Cube(cubeWidth, cubeHeight, cubeDepth, xco, zco);
        objects.push(cube);
        allObjects.push(cube);
        //document.getElementById('details').innerHTML = "<center><img src = 'cube.png'></center><br>This is cube. Cube is cute and green but only that. It has no impacts whatsoever."
          
        scene.add(cube);
        render();
	}

	//Function to change background color of the game
	function updateBackground() {
		if (trees > 2) {
			scene.background = new THREE.Color( 0xC1FFFF );
			render();
		}
	}
	
	$(document).ready(function () {
        $("#remove").click(function () {
            $(this).closest('.ui-dialog-content').dialog('close'); 
        });
    });

	</script>
	<div class = "takaisin"><a href = "mapstesti.html">Back to map</a></div>
	<div class = "lisays"><button id = "cube" onclick = "addCube()"><span>Add cube!</span></button></div>
	<div id="success" title="Cube">
    <p>You have clicked an object! Object index: <p id = "oi"></p>Location: <p id = "ox"></p><p id = "oz"></p><button id = "remove" onclick = "removeObject()">Remove object</button></p>
    </div>
    <div id = "details"></div>
	<!--<div class = "incs">Click add cube to add cube to yard. Drag and drop it to the place you want<br>Delete cube by doubleclicking it</div>--><!--<button onclick = "addTree()">Add tree!</button></div>-->

	<!--<div class = "pisteet">
		<div id = "puut">0</div>
	</div>-->
</body>
</html>