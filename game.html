<!DOCTYPE HTML>
<html>
<head>
	<title>Example Address 1</title>
</head>
<body>
	<!--Linking JavaScript and CSS-files-->
	<link rel="stylesheet" href="//code.jquery.com/ui/1.12.1/themes/base/jquery-ui.css">
	<link rel = "stylesheet" href = "css/ihanpihallacss.css">
    <!--<link rel="stylesheet" href="/resources/demos/style.css">-->
	<script src = "js/three.min.js"></script>
	<script src = "js/OrbitControls.js"></script>
	<script src = "js/OBJLoader.js"></script>
	<script src = "js/dat.gui.min.js"></script>
	<script src = "js/Cube.js"></script>
	<script src = "js/mousefunctions.js"></script>
	<script src = "https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
	<script src = "https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src = "https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
	<script type = "text/javascript">

	//Some variables
	var scene, camera, renderer;
	var mouse = new THREE.Vector2();

	//Array to store all objects, including buildings
	var allObjects = [];
	var value = 85000;
	var appletrees = 0;
	var trees = 0;
	var benches = 0;
	var tables = 0;
	var optimalApples = 10;
	var optimalTrees = 10;
	var optimalBenches = 15;
	var optimalTables = 10;
	var beeMeter = 0;
	var birdMeter = 0;
	var wormMeter = 0;


	//Array to store clickable objects
	var objects = [];
	var raycaster = new THREE.Raycaster();
	var container;
	var SELECTED;
	var INTERSECTED;
	var ADDED;
	var intersection = new THREE.Vector3();
	var offset = new THREE.Vector3();
	var controls;
	var trees = 0;
	var plane = new THREE.Plane();

	var directionalLight;

	var i = 0;
	var dragged = false;
	var selectedId;
	var borderX, borderY;
	var borderXX, borderYY;

	var previousX;
	var previousZ;
	var onTop;

	var totalpoints = 0;

	init();
	//animate();

        //Initializer-function to initialize the whole thing
	function init() {

		container = document.createElement( 'div' );
		document.body.appendChild( container );

		//Creating scene. Scene is where everything is added.
		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xC1FFFF );

		//Creating camera and giving it its position.
		camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
		
		//Camera is in position where x=30, y=20 and z=0
		camera.position.set(-30,50,30);
		
		//Camera looks to the centre of scene, (I guess it's point 0,0,0)
		//camera.lookAt(scene.position);
		camera.lookAt(new THREE.Vector3(50,0,0));

        //Renderer stuff
		renderer = new THREE.WebGLRenderer();
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;

		renderer.shadowCameraNear = 3;
		renderer.shadowCameraFar = camera.far;
		renderer.shadowCameraFov = 50;

		renderer.shadowMapBias = 0.0039;
		renderer.shadowMapDarkness = 0.1;
		renderer.shadowMapWidth = 1024;
		renderer.shadowMapHeight = 1024;

		var loader = new THREE.OBJLoader();

		loader.load(
			// resource URL
			'objects/models-detailed/model_C_building1.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                    	var material = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            wrapAround: true,
                            needsUpdate: true
                        });
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0xffd72c);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,0,0);
				object.rotateY(Math.PI / 2.8);
				object.scale.set(0.0005,0.0005,0.0005);
				object.updateMatrix();
				//object.castShadow = true;
				object.userData = { OBID: i, TYPE: "Building", REX: -15.6, REZ: -7.6};
				i++;
				scene.add( object );
				render();
				allObjects.push(object);
			}
		);

        loader.load(
			// resource URL
			'objects/models-detailed/model_C_building2.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                    	var material = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            wrapAround: true,
                            needsUpdate: true
                        });
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0xff8c00);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,0,0);
				object.rotateY(Math.PI / 2.8);
				object.scale.set(0.0005,0.0005,0.0005);
				object.updateMatrix();
				object.castShadow = true;
				object.userData = { OBID: i, TYPE: "Building", REX: 16.9, REZ: 5.2};
				i++;
				scene.add( object );
				render();
				allObjects.push(object);
			}
		);

        loader.load(
			// resource URL
			'objects/models-detailed/model_C_building3.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                    	var material = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            wrapAround: true,
                            needsUpdate: true
                        });
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0x1b8690);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,0,0);
				object.rotateY(Math.PI / 2.8);
				object.scale.set(0.0005,0.0005,0.0005);
				object.updateMatrix();
				object.castShadow = true;
				object.userData = { OBID: i, TYPE: "Building", REX: 11.9, REZ: 28.4};
				i++;
				scene.add( object );
				render();
				allObjects.push(object);
			}
		);

        loader.load(
			// resource URL
			'objects/models-detailed/model_C_building4.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                    	var material = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            wrapAround: true,
                            needsUpdate: true
                        });
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0xff443d);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,0,0);
				object.rotateY(Math.PI / 2.8);
				object.scale.set(0.0005,0.0005,0.0005);
				object.updateMatrix();
				object.castShadow = true;
				object.userData = { OBID: i, TYPE: "Building", REX: -19.6, REZ: 17};
				i++;
				scene.add( object );
				render();
				allObjects.push(object);
			}
		);
/*
        loader.load(
			// resource URL
			'objects/models-detailed/model_C_grass.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                    	var material = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            wrapAround: true,
                            needsUpdate: true
                        });
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0xff443d);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,-100,0);
				//object.rotateY(Math.PI / 2.8);
				object.scale.set(0.05,5,0.05);
				object.updateMatrix();
				object.castShadow = true;
				ADDED = object;
				object.userData = { OBID: i, TYPE: "Building"};
				i++;
				scene.add( object );
				render();
				objects.push(object);
				allObjects.push(object);
			}
		);
*/
		/*
		0xffd72c
		0xff8c00
		0x1b8690
		0xff443d
		*/

        //Different lights. Pick your favourite
/*
        var light = new THREE.AmbientLight( 0x404040 ); // soft white light
		scene.add( light );
*/
		directionalLight = new THREE.DirectionalLight( 0xffffff, 0.8 );
		directionalLight.position.set( 40, 60, 45 );
		directionalLight.castShadow = true;
		scene.add( directionalLight );

		directionalLight.shadowCameraLeft = -40;
        directionalLight.shadowCameraRight = 30;
        directionalLight.shadowCameraTop = 35;
        directionalLight.shadowCameraBottom = -30;
/*
		var pointLight = new THREE.PointLight( 0xffffff, 1.5, 40 );
		pointLight.position.set( 0, 5, 0 );
		pointLight.castShadow = true;
		scene.add( pointLight );
*/
		var hemiLight = new THREE.HemisphereLight( 0xffffff, 0x080820, 0.8 );
		scene.add( hemiLight );

        //Adding event listeners to elements. Basically each action calls certain function. Parameter list is (mouse action, function and some boolean that I have no idea what it's meaning is:D)
        renderer.domElement.addEventListener( 'mousemove', onDocumentMouseMove, false );
		renderer.domElement.addEventListener( 'mousedown', onDocumentMouseDown, false );
		renderer.domElement.addEventListener( 'mouseup', onDocumentMouseUp, false );
		renderer.domElement.addEventListener( 'click', onDocumentMouseClick, false );

		//Not sure if this was important...
        ray = new THREE.Ray( camera.position, null );

        //Creating planeground for scene
        var geometry = new THREE.PlaneBufferGeometry( 300, 300, 32 );
		
		//Image to ground texture.
		var texture = THREE.ImageUtils.loadTexture( "img/grass5.jpg" );

		//Making texture spread in 2 directions. Without these, texture would look like bar code
		texture.wrapS = THREE.RepeatWrapping; 
		texture.wrapT = THREE.RepeatWrapping;

		//Repeating texture, lower the number is, lower the quality is...
		texture.repeat.set( 60, 60 ); 

		//Settng texture as map for material
		var material = new THREE.MeshLambertMaterial( {map:texture} );

		//Creating plane
		var planee = new THREE.Mesh( geometry, material );

		//Just inserting coordinates of borders to variables
		borderY = borderX = 15;
		borderYY = borderXX = -15;

		//Setting plane's position and rotation. If you remove minus in front of the rotation, the texture stays on the bottom
		planee.position.y = 0;
		planee.rotation.x = - Math.PI / 2;
		planee.receiveShadow = true;

		//Finally adding the plane to the scene
		scene.add( planee );

		//Setting vectors which define basically in which direction is the yard is and in which direction cubes move
		var dir = new THREE.Vector3(0,200,0);
		var centroid = new THREE.Vector3(0,0,0);
		plane.setFromNormalAndCoplanarPoint(dir, centroid);

		//Creating controls. Now it's possible to rotate the view and zoom
		controls = new THREE.OrbitControls(camera, renderer.domElement);
		controls.addEventListener( 'change', render );

		//Setting limits to rotation and zoom.
		//Vertical rotation is limited, so that it's not possible to look under the plane.
		controls.minPolarAngle = - Math.PI;
		controls.maxPolarAngle = Math.PI / 2 - 0.2;

		//No limits for horizontal rotation
		controls.minAzimuthAngle = -Infinity; // radians
		controls.maxAzimuthAngle = Infinity; // radians

		//Zoom limits
		controls.minDistance = 0;
		//controls.maxDistance = 30;

		//Adding event listener of window if window is resized
		window.addEventListener( 'resize', onWindowResize, false );

		//Render the scene together
		render();
	}

	//When window is resized, this function is called resizing window automatically. Most of this is copypasted...
	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

		//Render after resize to show the change immediately
		render();
	}

	function checkObjectsNotTopOfEachOther() {
		if (SELECTED) {
		var ind = allObjects.indexOf(SELECTED);
		var sxo = SELECTED.position.x + (SELECTED.scale.x / 2);
		var sxt = SELECTED.position.x - (SELECTED.scale.x / 2);
		var szo = SELECTED.position.z + (SELECTED.scale.z / 2);
		var szt = SELECTED.position.z - (SELECTED.scale.z / 2);

		for (var i = 0; i < allObjects.length; i++) {
			if (i != ind) {
				var aoxo = allObjects[i].position.x + (allObjects[i].scale.x / 2);
				var aoxt = allObjects[i].position.x - (allObjects[i].scale.x / 2);
				var aozo = allObjects[i].position.z + (allObjects[i].scale.z / 2);
				var aozt = allObjects[i].position.z - (allObjects[i].scale.z / 2);
				if (((sxo >= aoxt) && (szo >= aozt) && (szt <= aozt) && (sxt <= aoxt)) || ((szo >= aozt) && (sxt <= aoxo) && (sxo >= aoxo) && (szt <= aozt)) || ((aoxo >= sxt) && (aozo >= szt) && (aozt <= szt) && (aoxt <= sxt)) || ((aozo >= szt) && (aoxt <= sxo) && (aoxo >= sxo) && (aozt <= szt))) {
					onTop = 1;
					break;
				} else {
					onTop = 0;
				}
			}
		};
		return onTop;
	}
	}

	function removeObject() {
		var removeType = INTERSECTED.parent.userData.TYPE;
		if (removeType === "Tree") {
			trees--;
			totalpoints -= (optimalTrees - trees) * 100;
			totalpoints -= checkLocation(INTERSECTED.parent.matrixWorld.getPosition().x + INTERSECTED.parent.userData.REX, INTERSECTED.parent.matrixWorld.getPosition().z + INTERSECTED.parent.userData.REZ);
		} else if (removeType === "Apple tree") {
			appletrees--;
			totalpoints -= (optimalApples - appletrees) * 100;
			totalpoints -= checkLocation(INTERSECTED.parent.matrixWorld.getPosition().x + INTERSECTED.parent.userData.REX, INTERSECTED.parent.matrixWorld.getPosition().z + INTERSECTED.parent.userData.REZ);
		} else if (removeType === "Table bench") {
			tables--;
			totalpoints -= (optimalTables - tables) * 100;
		} else if (removeType === "Bench") {
			benches--;
			totalpoints -= (optimalBenches - benches) * 100;
		}
		var ind = objects.indexOf(INTERSECTED.parent);
		var indd = allObjects.indexOf(INTERSECTED.parent);
		objects.splice(ind, 1);
		allObjects.splice(indd, 1);
		scene.remove(INTERSECTED.parent);
		document.getElementById('points').innerHTML = "<center>" + totalpoints + "</center>";
		render();
	}

	function calculatePoints( OBJECTP ) {
		var appletrees = 0;
	    var trees = 0;
	    var benches = 0;
	    var tables = 0;
	    var optimalApples = 10;
	    var optimalTrees = 10;
	    var optimalBenches = 15;
	    var optimalTables = 10;
	    var apoints = 0;

	    var objectType = OBJECTP.userData.TYPE;

		for (var i = 0; i < objects.length; i++) {
			var removeType = objects[i].userData.TYPE;
		if (removeType === "Tree") {
			trees++;
		} else if (removeType === "Apple tree") {
			appletrees++;
		} else if (removeType === "Table bench") {
			tables++;
		} else if (removeType === "Bench") {
			benches++;
		}
		};
		if (objectType === "Tree") {
			apoints = optimalTrees - trees + 1;
			apoints = apoints * 100;
			apoints += checkLocation(OBJECTP.matrixWorld.getPosition().x + OBJECTP.userData.REX, OBJECTP.matrixWorld.getPosition().z + OBJECTP.userData.REZ);
		} else if (objectType === "Apple tree") {
			apoints = optimalTrees - appletrees + 1;
			apoints = apoints * 100;
			apoints += checkLocation(OBJECTP.matrixWorld.getPosition().x + OBJECTP.userData.REX, OBJECTP.matrixWorld.getPosition().z + OBJECTP.userData.REZ);
		} else if (objectType === "Table bench") {
			apoints = optimalTables - tables + 1;
			apoints = apoints * 100;
		} else if (objectType === "Bench") {
			apoints = optimalBenches - benches + 1;
			apoints = apoints * 100;
		}
		totalpoints = totalpoints + apoints;
		if (totalpoints < 0) {
			totalpoints = 0;
		}
		document.getElementById('points').innerHTML = "<center>" + totalpoints + "</center>";
	}

	//Checks the distance between tree and building

	function checkLocation(xc, zc) {
		if ((xc <= 3.4 && xc >= -8) && (zc <= 14.7 && zc >= 3.3)) {
			return 1000;
		} else {
			return 0;
		}
	}

	function cancelDragAndDrop() {
		scene.remove(SELECTED);
		SELECTED.position.x = previousX;
		SELECTED.position.z = previousZ;
		scene.add(SELECTED);
		SELECTED = null;
	}

	//Animation function. Not needed...
	function animate() {
		requestAnimationFrame( animate );
		var timer = Date.now() * 0.005;
		directionalLight.position.x = Math.cos( timer ) * 10;
        directionalLight.position.z = Math.sin( timer ) * 10;
		render();
	}

	//Rendering function
	function render() {
		var timer = Date.now() * 0.0005;
		camera.lookAt( scene.position );
		renderer.render(scene, camera);
	}

	function addApple() {
		var loader = new THREE.OBJLoader();
		var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        //normalMap: normalMap,
        wrapAround: true,
        needsUpdate: true
        });
		// load a resource
		loader.load(
			// resource URL
			'objects/model_C_appletree.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0xace02e);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,0,0);
				object.scale.set(0.0005, 0.0005, 0.0005);
				//object.updateMatrix();
				object.castShadow = true;
				object.receiveShadow = true;
				object.userData = { OBID: i, TYPE: "Apple tree", REX: -32, REZ: 35 };
				ADDED = object;
				scene.add( object );
				render();
				allObjects.push(object);
				objects.push(object);
				i++;
				appletrees++;
				document.getElementById('info').innerHTML = "Apple tree attracts pollinators, which help the yard to be greener. It also attracts birds, that eat pests. And it's nice to collect fruits at the end of the summer.";
				document.getElementById("typename").innerHTML = object.userData.TYPE;
			}
		);

	}

	function addTablebench() {
		var loader = new THREE.OBJLoader();
		var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        //normalMap: normalMap,
        wrapAround: true,
        needsUpdate: true
        });
		// load a resource
		loader.load(
			// resource URL
			'objects/model_C_tablebenches.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0x996306);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,0,0);
				object.scale.set(0.001,0.001,0.001);
				//object.updateMatrix();
				object.castShadow = true;
				object.receiveShadow = true;
				object.userData = { OBID: i, TYPE: "Table bench" , REX: -62, REZ: 50 };
				ADDED = object;
				scene.add( object );
				render();
				allObjects.push(object);
				objects.push(object);
				i++;
				tables++;
				document.getElementById('info').style.visibility = "visible";
				document.getElementById('typename').innerHTML = object.userData.TYPE;
			}
		);

	}

	function addBench() {
		var loader = new THREE.OBJLoader();
		var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        //normalMap: normalMap,
        wrapAround: true,
        needsUpdate: true
        });
		// load a resource
		loader.load(
			// resource URL
			'objects/model_C_bench.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        //child.material.ambient.setHex(0xFF0000);
                        child.material.color.setHex(0xf2cf8a);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				//object.matrixWorld(2,0,2);
				object.scale.set(0.0008,0.0008,0.0008);
				object.position.set(0,0,0);
				//object.updateMatrix();
				object.castShadow = true;
				object.userData = { OBID: i, TYPE: "Bench" , REX: -50, REZ: 39};
				ADDED = object;
				scene.add( object );
				render();
				allObjects.push(object);
				objects.push(object);
				i++;
				benches++;
				document.getElementById('info').style.visibility = "visible";
				document.getElementById('typename').innerHTML = object.userData.TYPE;
			}
		);

	}

	function addTree() {
		var loader = new THREE.OBJLoader();
		var material = new THREE.MeshPhongMaterial({
        color: 0xffffff,
        wrapAround: true,
        needsUpdate: true
        });
		// load a resource
		loader.load(
			// resource URL
			'objects/model_C_tree.obj',
			// Function when resource is loaded
			function ( object ) {
				object.traverse( function ( child ) {
                    if ( child instanceof THREE.Mesh ) {
                        //child.material.ambient.setHex(0xFF0000);
                        child.material = material;
                        child.material.color.setHex(0x08dd0f);
                        child.castShadow = true;
				        child.receiveShadow = true;
                    }
                } );
				object.position.set(0,0,0);
				object.scale.set(0.0005,0.0005,0.0005);
				object.castShadow = true;
				object.userData = { OBID: i, TYPE: "Tree", REX: -5, REZ: 33 };
				raycaster.ray.intersectPlane( plane, intersection );
				i++;
				trees++;
				ADDED = object;
				scene.add( object );
				render();
				allObjects.push(object);
				objects.push(object);
				document.getElementById('treeinfo').style.visibility = "visible";
				document.getElementById('typename').innerHTML = object.userData.TYPE;
			}
		);

	}
	//Function to change background color of the game
	function updateBackground() {
		if (trees > 2) {
			scene.background = new THREE.Color( 0xC1FFFF );
			render();
		}
	}

	function listIndexes() {
		var indlist = "Amount: " + allObjects.length + "<br>Types of objects:<br>";
		for (var i = 0; i < allObjects.length; i++) {
			indlist += allObjects[i].userData.OBID + ": " + allObjects[i].userData.TYPE + "<br>";
		};
		document.getElementById('details').innerHTML = indlist;
	}

	function getDistance(objoi, objti) {
		var dobjo = new THREE.Object3D();
		for (var i = 0; i < objects.length; i++) {
			if (objects[i].userData.OBID == objoi) {
				dobjo = objects[i];
			}
		};
		var dobjt = new THREE.Object3D();
		for (var i = 0; i < objects.length; i++) {
			if (objects[i].userData.OBID == objti) {
				dobjt = objects[i];
			}
		};

		var xo = dobjo.position.x + dobjo.userData.REX;
		var xt = dobjt.position.x + dobjt.userData.REX;
		var xy = xo - xt;
		if (xy < 0) {
			xy = xy * (-1);
		};
		var zo = dobjo.position.z + dobjo.userData.REZ;
		var zt = dobjt.position.z + dobjt.userData.REZ;
		var zy = zo - zt;
		if (zy < 0) {
			zy = zy * (-1);
		};

		//Returning distance with two decimals
		return Math.sqrt(Math.pow(xy, 2) + Math.pow(zy, 2));
	}
	
	$(document).ready(function () {
        $("#remove").click(function () {
        	document.getElementById("success").title = "";
            $(this).closest('.ui-dialog-content').dialog('close'); 
        });
    });

    function closeNav() {
    	document.getElementById("mysideNav").style.width = "0px";
    	document.getElementById("downpanel").style.width = "100%";
    	document.getElementById("downpanel").style.left = "0%";
    	document.getElementById("takaisin").style.visibility = 'visible';
    }

    function openNav() {
    	document.getElementById("mysideNav").style.width = "20%";
    	document.getElementById("downpanel").style.width = "80%";
    	document.getElementById("downpanel").style.left = "20%";
    	document.getElementById("takaisin").style.visibility = 'none';
    	if (document.getElementById("mysideNav").style.width == "20%") {
    		document.getElementById("sidenavcontain").style.visibility = 'visible';
    	}
    }

	</script>

	<a href = "javascript:history.back()" class="closegame">&times;</a>
	<div id = "takaisin" class = "takaisin"><a onClick = "openNav()">Elements</a></div>
	<div id = "mysideNav" class = "sideNav">
		<div id = "sidenavcontain">
		<h2>Elements</h2>
		<a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
		<a href = "#" onclick = "addApple()">Add apple tree!</a><br>
		<a href = "#" onclick = "addTree()">Add tree!</a><br>
		<a href = "#" onclick = "addBench()">Add bench!</a><br>
		<a href = "#" onclick = "addTablebench()">Add tablebench!</a>
		<div id = "info">
			<h2 id = "typename"></h2>
			<p id = "info"></p>
			<p id = "treeinfo">Tree attracts pollinators, which help the yard to be greener. It also attracts birds, that eat pests.</p>
		</div>
	</div>
    </div>
	<div id="success" title="">
    <p>You have clicked an object! Object index: <p id = "oi"></p>Location: <p id = "ox"></p><p id = "oz"></p><p id = "distances"></p><button id = "remove" onclick = "removeObject()">Remove object</button></p>
    </div>
    <div id = "downpanel">
    	<div id = "gallery"><h1><a href = "gallery.html">Gallery</a></h1></div>
        <div id = "userbox">
        	<table>
        		<tr><td><h2>Santa Claus</h2></td></tr>
        		<tr><td><div id ="myProgress"><div id = "myBar"></div></div></td></tr>
        		<tr><td>Immortal</td></tr>
        		<tr><td>Log out</td></tr>
        	</table>
        </div>
        <div id = "points"><center>0</center></div>
    </div>
</body>
</html>
